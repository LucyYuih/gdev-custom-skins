// SCRIPT A — UI final (ajustes: modal de difficulties sobre a UI, remove "Abrir", hover animation)
// Base: sua versão anterior (mantive toda a lógica de download/difficulty intacta).
(function () {
  if (document.getElementById("gdjs-mod-list-ui-final")) return;

  // --- REPO STORAGE / HELPERS ---
  const REPO_STORAGE_KEY = "gdjs_repo_list_v1";
  const ACTIVE_REPO_KEY = "gdjs_active_repo_id_v1";

  function defaultRepoEntry() {
    return { id: "official", name: "oficial (LucyYuih/gdev-custom-charts)", owner: "LucyYuih", repo: "gdev-custom-charts", branch: "main", enabled: true };
  }

  function loadRepoList() {
    try {
      const raw = localStorage.getItem(REPO_STORAGE_KEY);
      if (!raw) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
      return JSON.parse(raw);
    } catch (e) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
  }

  function saveRepoList(list) {
    try { localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list || [])); } catch(e){}
  }

  function getActiveRepo() {
    try {
      const id = localStorage.getItem(ACTIVE_REPO_KEY);
      const list = loadRepoList();
      let pick = list.find(r => r.id === id && r.enabled);
      if (!pick) pick = list.find(r => r.enabled) || list[0];
      return pick || defaultRepoEntry();
    } catch(e){ return defaultRepoEntry(); }
  }

  function setActiveRepoById(id) { try { localStorage.setItem(ACTIVE_REPO_KEY, String(id)); } catch(e){} }

  function makeRepoId() { return "r_" + Math.random().toString(36).slice(2,10); }

  // parse inputs like "owner/repo@branch" OR a full manifest URL
  function parseRepoInput(input) {
    if (!input) return null;
    input = input.trim();
    if (/manifest\.json/.test(input) || /^https?:\/\//.test(input)) {
      const m = input.match(/cdn\.jsdelivr\.net\/gh\/([^\/]+)\/([^@\/]+)@([^\/]+)\/.*manifest\.json/i);
      if (m) return { owner: m[1], repo: m[2], branch: m[3], manifestUrl: input };
      return { owner: "", repo: "", branch: "", manifestUrl: input };
    }
    const m2 = input.match(/^([^\/\s]+)\/([^@\/\s]+)(?:@(.+))?$/);
    if (m2) {
      return { owner: m2[1], repo: m2[2], branch: m2[3] || "main" };
    }
    return null;
  }

  function buildManifestCdnUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl;
    if (entry.owner && entry.repo) return `https://cdn.jsdelivr.net/gh/${entry.owner}/${entry.repo}@${entry.branch}/manifest.json`;
    return null;
  }

  // --- small util helpers ---
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function isAudioFile(name){ return /\.(mp3|ogg|wav|aac|m4a)$/i.test(name); }
  function isJsonFile(name){ return /\.json$/i.test(name); }
  function basenameNoExt(p){ if(!p) return ""; const s = p.split("/").pop(); return s.replace(/\.[^.]+$/, ""); }

  // --- MANIFEST / GITHUB helpers ---
  async function tryManifestFromGameVar(runtimeScene) {
    try {
      if (typeof runtimeScene !== "undefined" && runtimeScene.getGame) {
        const gg = runtimeScene.getGame().getVariables();
        if (gg.has("manifestjson")) {
          const s = gg.get("manifestjson").getAsString();
          if (s && s.trim()) {
            try { return JSON.parse(s); } catch(e) { return null; }
          }
        }
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromProjectResource() {
    try {
      const tries = ["manifest.json","resources/manifest.json","res/manifest.json","./manifest.json"];
      for (const p of tries) {
        try { const r = await fetch(p, {cache:"no-cache"}); if (r.ok) { try { return await r.json(); } catch(e){} } } catch(e){}
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromCdnOf(entry) {
    try {
      const url = buildManifestCdnUrl(entry);
      if (!url) return null;
      const r = await fetch(url, {cache:"no-cache"});
      if (r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  async function tryManifestFromGithubApiFor(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) throw new Error("Invalid repo entry");
    const apiUrl = `https://api.github.com/repos/${entry.owner}/${entry.repo}/contents/${encodeURIComponent(path)}?ref=${entry.branch || "main"}`;
    let token = "";
    try { token = localStorage.getItem("gdjs_github_token") || ""; } catch(e){}
    const headers = token ? { "Authorization": "token " + token } : {};
    const r = await fetch(apiUrl, { headers });
    if (!r.ok) throw new Error(`GitHub API: ${r.status}`);
    const json = await r.json();
    return await json.map(item => ({ name: item.name, path: item.path, type: item.type, download_url: item.download_url || null }));
  }

  const _manifest_cache_by_repo = {};

  async function loadManifestPreferLocalFor(entry, runtimeScene) {
    const repoId = (entry && entry.id) ? entry.id : "__default__";
    if (typeof _manifest_cache_by_repo[repoId] !== "undefined") return _manifest_cache_by_repo[repoId];

    const a = await tryManifestFromGameVar(runtimeScene); if (a) { _manifest_cache_by_repo[repoId] = a; return a; }
    const b = await tryManifestFromProjectResource(); if (b) { _manifest_cache_by_repo[repoId] = b; return b; }
    const c = await tryManifestFromCdnOf(entry); if (c) { _manifest_cache_by_repo[repoId] = c; return c; }
    _manifest_cache_by_repo[repoId] = null;
    return null;
  }

  async function ghListForFolderUsingEntry(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) {
      throw new Error("No GitHub owner/repo specified for ghList");
    }
    return await tryManifestFromGithubApiFor(entry, path);
  }

  // --- UI: main container (full screen) ---
  const container = document.createElement("div");
  container.id = "gdjs-mod-list-ui-final";
  Object.assign(container.style, {
    position: "fixed", left: "0", top: "0", right: "0", bottom: "0",
    zIndex: 9999999, fontFamily: "Inter, system-ui, Arial", color: "#eee",
    overflow: "hidden", display: "flex", flexDirection: "column",
    background: "linear-gradient(180deg, rgba(12,12,12,0.98), rgba(8,8,8,0.95))"
  });

  // Header
  const header = document.createElement("div");
  Object.assign(header.style, { padding: "10px", display: "flex", gap: "8px", alignItems: "center", borderBottom: "1px solid rgba(255,255,255,0.04)", flex: "0 0 auto" });
  header.innerHTML = `
    <div style="display:flex;gap:8px;align-items:center">
      <div style="font-weight:700">Mods</div>
      <select id="gdjs-repo-select" style="padding:6px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"></select>
      <button id="gdjs-repo-manage" style="padding:6px;border-radius:6px">Gerenciar Repos</button>
      <button id="gdjs-repo-refresh" style="padding:6px;border-radius:6px">Atualizar</button>
      <button id="gdjs-repo-cache" style="padding:6px;border-radius:6px">Ver Cache</button>
    </div>
    <input id="gdjs-final-search" placeholder="Pesquisar mods / músicas..." style="margin-left:8px;flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0b0b0b;color:#eee" />
    <button id="gdjs-final-close" style="margin-left:8px;padding:6px;border-radius:6px">Fechar</button>
  `;

  // Main split
  const main = document.createElement("div");
  Object.assign(main.style, { display: "flex", gap: "10px", padding: "10px", flex: "1 1 auto", minHeight: 0, overflow: "hidden" });

  const leftPane = document.createElement("div");
  Object.assign(leftPane.style, { width: "38%", minWidth: "260px", maxWidth: "640px", overflowY: "auto", borderRight: "1px solid rgba(255,255,255,0.03)", paddingRight: "8px" });

  const rightPane = document.createElement("div");
  Object.assign(rightPane.style, { flex: "1 1 auto", overflowY: "auto", paddingLeft: "8px" });

  const footer = document.createElement("div");
  Object.assign(footer.style, { padding: "10px", borderTop: "1px solid rgba(255,255,255,0.04)", display: "flex", gap: "12px", alignItems: "center", flex: "0 0 auto" });
  footer.innerHTML = `<div id="gdjs-final-status" style="font-size:13px;opacity:0.9"></div><div id="gdjs-final-last" style="margin-left:auto;font-size:13px;opacity:0.85"></div>`;

  container.appendChild(header);
  main.appendChild(leftPane); main.appendChild(rightPane);
  container.appendChild(main); container.appendChild(footer);
  document.body.appendChild(container);

  // refs
  const repoSelect = document.getElementById("gdjs-repo-select");
  const btnManage = document.getElementById("gdjs-repo-manage");
  const btnRefresh = document.getElementById("gdjs-repo-refresh");
  const btnCache = document.getElementById("gdjs-repo-cache");
  const btnClose = document.getElementById("gdjs-final-close");
  const searchInput = document.getElementById("gdjs-final-search");
  const statusEl = document.getElementById("gdjs-final-status");
  const lastEl = document.getElementById("gdjs-final-last");

  function setStatus(s){ statusEl.textContent = s || ""; }
  function setLast(s){ lastEl.textContent = s || ""; }

  // state
  let currentModPath = "";
  let modsList = [];
  let songsList = [];
  let modElementMap = {};
  let songElementMap = {};

  // --- REPO UI / MANAGEMENT ---
  function renderRepoSelect() {
    const list = loadRepoList();
    repoSelect.innerHTML = "";
    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.id;
      opt.textContent = (r.enabled ? "● " : "○ ") + (r.name || (r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl || "custom"));
      repoSelect.appendChild(opt);
    }
    const active = getActiveRepo();
    setActiveRepoById(active.id);
    try { repoSelect.value = active.id; } catch(e){}
  }

  function showRepoManagerModal() {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Gerenciar Repositórios</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Formato: owner/repo@branch ou URL do manifest</div></div><div style="margin-top:10px" id="gdjs-repo-list-area"></div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <input id="gdjs-repo-input" placeholder="ex: LucyYuih/gdev-custom-charts@main" style="flex:1;padding:8px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"/>
        <button id="gdjs-repo-add" style="padding:8px;border-radius:6px">Adicionar</button>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="gdjs-repo-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-repo-list-area");
    function renderListArea() {
      const lst = loadRepoList();
      listArea.innerHTML = "";
      for (const r of lst) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "6px", borderRadius: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))", marginBottom: "6px" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${r.name || (r.owner? (r.owner + "/" + r.repo) : r.manifestUrl)}</div><div style="font-size:12px;opacity:0.8">${r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl}</div>`;
        const controls = document.createElement("div"); controls.style.display = "flex"; controls.style.gap = "6px";
        const toggle = document.createElement("button"); toggle.textContent = r.enabled ? "Ativo" : "Desativar"; toggle.style.padding = "6px"; toggle.style.borderRadius = "6px";
        toggle.onclick = () => { r.enabled = !r.enabled; saveRepoList(lst); renderListArea(); renderRepoSelect(); };
        const setActiveBtn = document.createElement("button"); setActiveBtn.textContent = "Selecionar"; setActiveBtn.style.padding = "6px"; setActiveBtn.style.borderRadius = "6px";
        setActiveBtn.onclick = () => { setActiveRepoById(r.id); renderRepoSelect(); loadFolder(""); overlay.remove(); };
        const del = document.createElement("button"); del.textContent = "Excluir"; del.style.padding = "6px"; del.style.borderRadius = "6px";
        del.onclick = () => { const idx = lst.findIndex(x=>x.id===r.id); if (idx>=0) { lst.splice(idx,1); saveRepoList(lst); renderListArea(); renderRepoSelect(); } };
        controls.appendChild(toggle); controls.appendChild(setActiveBtn); controls.appendChild(del);
        row.appendChild(label); row.appendChild(controls); listArea.appendChild(row);
      }
      if ((lst||[]).length === 0) listArea.innerHTML = "<div style='opacity:0.8'>Nenhum repositório adicionado.</div>";
    }
    renderListArea();

    const input = box.querySelector("#gdjs-repo-input");
    const addBtn = box.querySelector("#gdjs-repo-add");
    addBtn.onclick = () => {
      const v = input.value.trim();
      if (!v) return;
      const parsed = parseRepoInput(v);
      if (!parsed) { alert("Formato inválido"); return; }
      const list = loadRepoList();
      const entry = { id: makeRepoId(), name: parsed.owner? (parsed.owner + "/" + parsed.repo + (parsed.branch? "@" + parsed.branch : "")) : (parsed.manifestUrl || v), owner: parsed.owner||"", repo: parsed.repo||"", branch: parsed.branch||"main", manifestUrl: parsed.manifestUrl||null, enabled: true };
      list.push(entry); saveRepoList(list); input.value = ""; renderListArea(); renderRepoSelect();
    };

    box.querySelector("#gdjs-repo-close").onclick = () => overlay.remove();
  }

  // --- CACHE manager modal ---
  function showCacheManager() {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "760px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Cache de Músicas</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Gerencie músicas baixadas</div></div>
      <div id="gdjs-cache-list" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
        <button id="gdjs-cache-clear" style="padding:8px;border-radius:6px">Limpar Tudo</button>
        <button id="gdjs-cache-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-cache-list");
    function renderCache() {
      const keys = Object.keys(window.gdjsCustomAudio || {});
      listArea.innerHTML = "";
      if (!keys || keys.length === 0) { listArea.innerHTML = "<div style='opacity:0.8'>Nenhuma música em cache.</div>"; return; }
      for (const k of keys) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "8px", borderRadius: "6px", marginBottom: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${k}</div><div style="font-size:12px;opacity:0.8">${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].audios) || {}).length} audios • ${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].rawFiles) || {}).length} jsons</div>`;
        const btns = document.createElement("div"); btns.style.display = "flex"; btns.style.gap = "6px";
        const del = document.createElement("button"); del.textContent = "Deletar"; del.style.padding = "6px"; del.style.borderRadius = "6px";
        del.onclick = () => { delete window.gdjsCustomAudio[k]; try { /* revoke blobs if any */ } catch(e){} renderCache(); };
        const openBtn = document.createElement("button"); openBtn.textContent = "Abrir pasta"; openBtn.style.padding = "6px"; openBtn.style.borderRadius = "6px";
        openBtn.onclick = () => { showCacheDetails(k); };
        btns.appendChild(openBtn); btns.appendChild(del);
        row.appendChild(label); row.appendChild(btns); listArea.appendChild(row);
      }
    }

    function showCacheDetails(key) {
      const data = window.gdjsCustomAudio && window.gdjsCustomAudio[key];
      const modal = document.createElement("div");
      Object.assign(modal.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000001, display: "flex", alignItems: "center", justifyContent: "center" });
      const b = document.createElement("div"); Object.assign(b.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", color: "#eee" });
      b.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${key}</div><div id="gdjs-cache-detail-list" style="display:flex;flex-direction:column;gap:6px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button id="gdjs-cache-detail-close" style="padding:8px;border-radius:6px">Fechar</button></div>`;
      modal.appendChild(b); document.body.appendChild(modal);
      const listEl = b.querySelector("#gdjs-cache-detail-list");
      const audios = (data && data.audios) ? Object.keys(data.audios) : [];
      const raws = (data && data.rawFiles) ? Object.keys(data.rawFiles) : [];
      if (audios.length === 0 && raws.length === 0) listEl.innerHTML = "<div style='opacity:0.8'>Vazio</div>";
      for (const a of audios) {
        const row = document.createElement("div"); row.style.display = "flex"; row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${a}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar"; btn.style.padding = "6px"; btn.style.borderRadius = "6px";
        btn.onclick = () => { try { delete data.audios[a]; } catch(e){} row.remove(); };
        row.appendChild(btn); listEl.appendChild(row);
      }
      for (const r of raws) {
        const row = document.createElement("div"); row.style.display = "flex"; row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${r}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar"; btn.style.padding = "6px"; btn.style.borderRadius = "6px";
        btn.onclick = () => { try { delete data.rawFiles[r]; } catch(e){} row.remove(); };
        row.appendChild(btn); listEl.appendChild(row);
      }
      b.querySelector("#gdjs-cache-detail-close").onclick = () => modal.remove();
    }

    box.querySelector("#gdjs-cache-clear").onclick = () => {
      if (!confirm("Deletar todo o cache de músicas?")) return;
      try { window.gdjsCustomAudio = {}; } catch(e){}
      renderCache();
    };

    box.querySelector("#gdjs-cache-close").onclick = () => overlay.remove();

    renderCache();
  }

  // --- rendering of mods (left) and songs (right) ---
  function renderModsList(items) {
    leftPane.innerHTML = "";
    modElementMap = {};
    if (!items || items.length === 0) { const e = document.createElement("div"); e.textContent = "Nenhum mod encontrado."; e.style.opacity = "0.8"; leftPane.appendChild(e); return; }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, {
        padding: "10px",
        borderRadius: "8px",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        gap: "8px",
        marginBottom: "8px",
        cursor: "pointer",
        background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))",
        transition: "transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease"
      });

      // hover animation (lift + scale + subtle shadow)
      row.addEventListener('mouseenter', ()=> {
        try {
          row.style.transform = "translateY(-4px) scale(1.02)";
          row.style.boxShadow = "0 10px 30px rgba(0,0,0,0.45)";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008))";
        } catch(e){}
      });
      row.addEventListener('mouseleave', ()=> {
        try {
          row.style.transform = "translateY(0) scale(1)";
          row.style.boxShadow = "none";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))";
        } catch(e){}
      });

      const left = document.createElement("div"); left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div>`;
      row.appendChild(left);

      // IMPORTANT: remove the "Abrir" button; the row itself is clickable
      row.onclick = ()=> openMod(item.path);

      leftPane.appendChild(row);
      modElementMap[item.path] = { element: row, data: item };
    }
  }

  function renderSongsList(items) {
    rightPane.innerHTML = "";
    songElementMap = {};
    if (!items || items.length === 0) { const e = document.createElement("div"); e.textContent = "Selecione um mod à esquerda."; e.style.opacity = "0.8"; rightPane.appendChild(e); return; }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, { padding: "10px", borderRadius: "8px", display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px", marginBottom: "8px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
      const left = document.createElement("div"); left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div><div style="font-size:12px;opacity:0.8">${item.path}</div>`;
      const right = document.createElement("div"); right.style.display = "flex"; right.style.gap = "8px";
      const checkBtn = document.createElement("button"); checkBtn.textContent = "Checando..."; checkBtn.disabled = true; checkBtn.style.padding="6px"; checkBtn.style.borderRadius="6px";
      right.appendChild(checkBtn);
      row.appendChild(left); row.appendChild(right); rightPane.appendChild(row);
      songElementMap[item.path] = { element: row, data: item, rightContainer: right, placeholderBtn: checkBtn, name: item.name };
    }
    startBackgroundCheckOnSongs(items);
  }

  // --- background check ---
  let bgController = null;
  const hasSubCache = {};

  function startBackgroundCheckOnSongs(items) {
    if (bgController && typeof bgController.abort === "function") try { bgController.abort(); } catch(e){}
    bgController = { aborted:false, abort(){ this.aborted=true; } };
    const list = items || [];
    const concurrency = 3;
    let idx = 0;
    const activeRepo = getActiveRepo();

    async function worker() {
      while(!bgController.aborted) {
        if (idx >= list.length) break;
        const p = list[idx++].path;
        try {
          if (typeof hasSubCache[p] !== "undefined") { updateButtonsForDecisionFromCache(p, hasSubCache[p]); await sleep(0); continue; }
          const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
          if (manifest && manifest.hasOwnProperty(p)) {
            const entry = manifest[p];
            if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "string") { hasSubCache[p] = true; updateButtonsForDecisionFromCache(p,true); await sleep(0); continue; }
            if (Array.isArray(entry) && entry.length>=0 && typeof entry[0] === "object") { hasSubCache[p] = false; updateButtonsForDecisionFromCache(p,false); await sleep(0); continue; }
          }
          try {
            const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
            const hasDir = Array.isArray(api) && api.some(x=>x.type==="dir");
            hasSubCache[p] = Boolean(hasDir);
            updateButtonsForDecisionFromCache(p, Boolean(hasDir));
          } catch(e) {
            hasSubCache[p] = false;
            updateButtonsForDecisionFromCache(p, false);
          }
        } catch(e){}
        await sleep(40);
      }
    }
    for (let i=0;i<concurrency;i++) worker();
  }

  function updateButtonsForDecisionFromCache(path, hasSubdirs) {
    const el = songElementMap[path];
    if (!el) return;
    const right = el.rightContainer; right.innerHTML = "";
    const itemName = el.name || path.split("/").pop();

    if (hasSubdirs) {
      const pickBtn = document.createElement("button"); pickBtn.textContent = "Selecionar difficulty"; pickBtn.style.padding="6px"; pickBtn.style.borderRadius="6px";
      pickBtn.onclick = async ()=>{
        try {
          setStatus("Carregando difficulties de " + itemName + "...");
          const activeRepo = getActiveRepo();
          const subdirs = await fetchSubdirsUsingEntry(activeRepo, path);
          if (!subdirs || subdirs.length === 0) { setStatus("Nenhuma difficulty encontrada."); return; }
          showDifficultyChooser(path, subdirs);
          setStatus("");
        } catch(e){ setStatus("Erro listando difficulties."); }
      };
      right.appendChild(pickBtn);
    } else {
      const dlBtn = document.createElement("button"); dlBtn.textContent = "Selecionar e baixar"; dlBtn.style.padding="6px"; dlBtn.style.borderRadius="6px";
      dlBtn.onclick = ()=> downloadSongFolder(path);
      right.appendChild(dlBtn);
    }
  }

  async function fetchSubdirsUsingEntry(entry, folderPath) {
    try {
      const manifest = await loadManifestPreferLocalFor(entry, window.runtimeScene || undefined);
      if (manifest && manifest.hasOwnProperty(folderPath)) {
        const entryv = manifest[folderPath];
        if (Array.isArray(entryv) && entryv.length>0 && typeof entryv[0] === "string") return entryv.slice();
      }
    } catch(e){}
    try {
      const api = await ghListForFolderUsingEntry(entry, folderPath);
      const dirs = (api || []).filter(i=> i.type === "dir").map(i=> i.name);
      return dirs;
    } catch(e){ return []; }
  }

  async function loadFolder(path="") {
    try {
      setStatus("Carregando pasta...");
      const activeRepo = getActiveRepo();
      for (const d of (modsList||[])) delete hasSubCache[d.path];
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const entry = manifest[path];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "string") {
          items = entry.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){
          items = [];
        }
      }
      modsList = items || [];
      currentModPath = "";
      renderModsList(modsList);
      renderSongsList([]);
      setStatus(((path||"Mods")) + ` — ${modsList.length}`);
      setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10);
    } catch (err) {
      modsList = []; renderModsList(modsList);
      setStatus("Erro carregando pasta: " + (err && err.message ? err.message : err));
    }
  }

  async function openMod(path) {
    try {
      setStatus("Abrindo " + path + "...");
      currentModPath = path;
      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const entry = manifest[path];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "string") {
          items = entry.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){ items = []; }
      }
      songsList = items || [];
      renderSongsList(songsList);
      setStatus(`${path} — ${songsList.length} músicas`);
    } catch(e){
      setStatus("Erro ao abrir mod: " + (e && e.message ? e.message : e));
    }
  }

  // --- download functions (mantive lógica original) ---
  function stopAndCleanupPrevious(options){
    options = options || {};
    const revokeBlobUrls = options.revokeBlobUrls === true;
    try {
      if (window.gdjsChannels) {
        Object.keys(window.gdjsChannels).forEach(k=>{
          try {
            const a = window.gdjsChannels[k];
            if (!a) return;
            try { a.pause(); } catch(e){}
            try { a.currentTime = 0; } catch(e){}
            if (a._gdjs_ended_handler) { try { a.removeEventListener('ended', a._gdjs_ended_handler); } catch(e){} a._gdjs_ended_handler = null; }
            try { if (revokeBlobUrls && a.src && a.src.startsWith('blob:')) URL.revokeObjectURL(a.src); } catch(e){}
          } catch(e){}
        });
      }

      if (window.gdjsCustomAudio) {
        Object.keys(window.gdjsCustomAudio).forEach(folder=>{
          try {
            const entry = window.gdjsCustomAudio[folder] || {};
            const audios = entry.audios || {};
            Object.keys(audios).forEach(name=>{
              try {
                const info = audios[name] || {};
                if (info && info.blobUrl && revokeBlobUrls) {
                  try { URL.revokeObjectURL(info.blobUrl); } catch(e){}
                }
              } catch(e){}
            });
            try { delete window.gdjsCustomAudio[folder]; } catch(e){}
          } catch(e){}
        });
      }

      window.gdjsChannels = {};
    } catch(e){}
  }

  async function findAudioFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);

    async function audioListFromManifestPath(p) {
      try {
        if (!manifest) return [];
        if (!manifest.hasOwnProperty(p)) return [];
        const entry = manifest[p];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "object") {
          return entry.filter(e=> isAudioFile(e.name)).map(e=> ({ name: e.name, url: e.url || e.raw_url || null }));
        }
      } catch(e){}
      return [];
    }

    async function audioListFromGithubPath(p) {
      try {
        const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
        return (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      } catch(e){}
      return [];
    }

    try {
      let list = await audioListFromManifestPath(difficultyPath);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(difficultyPath);
      if (list && list.length>0) return list;
    } catch(e){}

    try {
      let list = await audioListFromManifestPath(rootFolder);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(rootFolder);
      if (list && list.length>0) return list;
    } catch(e){}

    try {
      const parts = (rootFolder || "").split("/").filter(Boolean);
      if (parts.length >= 2) {
        const modFolder = parts.slice(0, parts.length - 1).join("/");
        if (modFolder) {
          let list = await audioListFromManifestPath(modFolder);
          if (list && list.length>0) return list;
          list = await audioListFromGithubPath(modFolder);
          if (list && list.length>0) return list;
        }
      }
    } catch(e){}
    return [];
  }

  async function downloadDifficultyKeepAudioRoot(rootFolder, difficultyName) {
    const difficultyPath = (rootFolder? rootFolder + "/" + difficultyName : difficultyName);
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });

      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder)); } catch(e){}

      setStatus("Listando arquivos (procura áudios: difficulty -> song -> mod)...");

      const audioFiles = await findAudioFilesWithFallback(rootFolder, difficultyPath);

      let chartFiles = [];
      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      if (manifest && manifest.hasOwnProperty(difficultyPath)) {
        const entry = manifest[difficultyPath];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "object") {
          chartFiles = entry.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url || e.raw_url || null }) );
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
          chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
        } catch(e){}
      }

      let rootJsons = [];
      if (manifest && manifest.hasOwnProperty(rootFolder)) {
        const entry = manifest[rootFolder];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "object") {
          rootJsons = entry.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url || e.raw_url || null }) );
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, rootFolder);
          rootJsons = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
        } catch(e){}
      }

      const allJsonsMap = {};
      rootJsons.forEach(j => { allJsonsMap[j.name] = j; });
      chartFiles.forEach(j => { allJsonsMap[j.name] = j; });

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];

      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name}); }
        } catch(e){}
        await sleep(0);
      }

      for (const name in allJsonsMap) {
        try {
          const j = allJsonsMap[name];
          setStatus("Baixando chart: " + name + "...");
          const r = await fetch(j.url);
          if (!r.ok) continue;
          const txt = await r.text();
          const key = difficultyName + "/" + name;
          dest.rawFiles[key] = txt;
          const lname = name.toLowerCase();
          const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
          if (gg) {
            if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
            else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
            else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
            else {
              try {
                const parsed = JSON.parse(txt);
                if (parsed && parsed.notes) {
                  if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                  else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                  else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                } else {
                  if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                }
              } catch(e){
                if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
              }
            }
          }
        } catch(e){}
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (difficulty: ' + difficultyName + ').');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  async function downloadAllDifficulties(rootFolder, subdirs) {
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder)); } catch(e){}

      setStatus("Procurando áudios (difficulty -> song -> mod)...");
      const hintDifficulty = (subdirs && subdirs.length>0) ? (rootFolder + "/" + subdirs[0]) : rootFolder;
      const audioFiles = await findAudioFilesWithFallback(rootFolder, hintDifficulty);

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];
      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name}); }
        } catch(e){}
        await sleep(0);
      }

      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      for (const d of subdirs) {
        try {
          setStatus("Baixando charts: " + d + " ...");
          let chartFiles = [];
          const difficultyPath = (rootFolder? rootFolder + "/" + d : d);
          if (manifest && manifest.hasOwnProperty(difficultyPath)) {
            const entry = manifest[difficultyPath];
            if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "object") {
              chartFiles = entry.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url || e.raw_url || null }) );
            }
          } else {
            try {
              const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
              chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
            } catch(e){}
          }
          for (const j of chartFiles) {
            try {
              const r = await fetch(j.url);
              if (!r.ok) continue;
              const txt = await r.text();
              const key = d + "/" + j.name;
              dest.rawFiles[key] = txt;
              const lname = j.name.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e){
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            } catch(e){}
            await sleep(0);
          }
        } catch(e){}
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (todas difficulties).');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  async function downloadSongFolder(folderPath) {
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });

      setStatus("Listando arquivos em " + folderPath + "...");
      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let files = null;
      if (manifest && manifest.hasOwnProperty(folderPath)) {
        const entry = manifest[folderPath];
        if (Array.isArray(entry) && entry.length>0 && typeof entry[0] === "object") {
          files = entry.map(e => ({ name: e.name, url: e.url || e.raw_url || null, type: e.type || "file" }));
        } else {
          files = [];
        }
      } else {
        try {
          const apiList = await ghListForFolderUsingEntry(activeRepo, folderPath);
          files = (apiList || []).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), type: i.type }));
          files = files.filter(x => x.type !== "dir");
        } catch(e){
          files = [];
        }
      }

      if (!Array.isArray(files) || files.length === 0) { setStatus("Pasta vazia."); return; }

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[folderPath] = window.gdjsCustomAudio[folderPath] || {audios:{}, rawFiles:{}};
      const dest = window.gdjsCustomAudio[folderPath];

      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(folderPath); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(folderPath.split("/").pop()||folderPath)); } catch(e){}

      const totalFiles = files.length;
      let processed = 0;
      let nextChannelIndex = (window.gdjsChannels) ? Object.keys(window.gdjsChannels).length : 0;
      const unlockQueue = [];

      for (const f of files) {
        processed++; setStatus(`${processed} / ${totalFiles}`);
        const fname = f.name || ("file" + processed);
        const url = f.url || f.download_url || null;
        if (!url) continue;

        if (isJsonFile(fname)) {
          try {
            const txtResp = await fetch(url);
            if (txtResp.ok) {
              const txt = await txtResp.text();
              dest.rawFiles[fname] = txt;
              const lname = fname.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e) {
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            }
          } catch(e){}
        } else if (isAudioFile(fname)) {
          try {
            setStatus("Baixando áudio: " + fname + "...");
            const resp = await fetch(url);
            if (!resp.ok) continue;
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            const audioEl = new Audio(blobUrl);
            audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
            dest.audios[fname] = { blobUrl, audioEl, audioElRef: audioEl };
            window.gdjsChannels = window.gdjsChannels || {};
            window.gdjsChannels[nextChannelIndex] = audioEl;
            nextChannelIndex++;
            try {
              const p = audioEl.play();
              if (p && typeof p.then === "function") {
                p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: fname}); });
              } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
            } catch(e){ unlockQueue.push({audioEl, name: fname}); }
            try { const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null; if (gg && !gg.get("SongName").getAsString()) gg.get("SongName").setString(basenameNoExt(fname)); } catch(e){}
          } catch(e){}
        }
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + folderPath + '".');
    } catch(e){
      setStatus("Erro ao baixar pasta: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  // --- difficulty chooser modal (z-index aumentado pra aparecer sobre a UI) ---
  function showDifficultyChooser(rootFolder, subdirs) {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000010, display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "auto" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "420px", maxHeight: "70vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="font-weight:700;margin-bottom:8px">Escolha uma difficulty para:</div><div style="margin-bottom:8px;color:#bbb">${rootFolder}</div>`;
    const list = document.createElement("div"); list.style.display = "flex"; list.style.flexDirection = "column"; list.style.gap = "6px";
    for (const d of subdirs) {
      const b = document.createElement("button");
      b.textContent = d;
      b.style.padding="8px"; b.style.borderRadius="6px";
      b.onclick = ()=> { overlay.remove(); downloadDifficultyKeepAudioRoot(rootFolder, d); };
      list.appendChild(b);
    }
    const cancel = document.createElement("button"); cancel.textContent = "Cancelar"; cancel.style.marginTop="10px"; cancel.style.padding="8px"; cancel.style.borderRadius="6px";
    cancel.onclick = ()=> overlay.remove();
    box.appendChild(list); box.appendChild(cancel);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
    // ensure focus / pointer events to overlay
    setTimeout(()=> { try { overlay.focus(); } catch(e){} }, 0);
  }

  // --- events wiring ---
  btnClose.onclick = ()=> container.remove();
  btnManage.onclick = ()=> showRepoManagerModal();
  btnCache.onclick = ()=> showCacheManager();
  btnRefresh.onclick = async ()=> {
    try { setStatus("Atualizando..."); } catch(e){}
    try { for (const it of modsList) delete hasSubCache[it.path]; } catch(e){}
    try { Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]); } catch(e){}
    await loadFolder(currentModPath || "");
  };

  repoSelect.onchange = ()=> {
    try { setActiveRepoById(repoSelect.value); } catch(e){}
    Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]);
    loadFolder("");
  };

  searchInput.addEventListener("input", ()=> {
    const q = searchInput.value.trim().toLowerCase();
    if (!q) { renderModsList(modsList); setStatus((currentModPath||"Mods")+` — ${modsList.length} pastas`); setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10); return; }
    const filtered = modsList.filter(it => it.name.toLowerCase().includes(q));
    renderModsList(filtered);
    setStatus(`Resultado: ${filtered.length} / ${modsList.length}`);
    setTimeout(()=> startBackgroundCheckOnSongs(filtered), 10);
  });

  (function init() {
    const list = loadRepoList();
    if (!list || list.length === 0) { saveRepoList([defaultRepoEntry()]); }
    renderRepoSelect();
    loadFolder("");
  })();

  try { if (typeof runtimeScene !== "undefined") window.runtimeScene = runtimeScene; } catch(e){}
})();
